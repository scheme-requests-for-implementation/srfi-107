<!--
SPDX-FileCopyrightText: 2013 Per Bothner <per@bothner.com>

SPDX-License-Identifier: MIT
-->

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>SRFI 107: XML reader syntax</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
  div.title h1 { font-size: small; color: blue }
  div.title { font-size: xx-large; color: blue; font-weight: bold }
  h1 { font-size: x-large; color: blue }
  h2 { font-size: large; color: blue }
  /* So var inside pre gets same font as var in paragraphs. */
  var { font-family: monospace; }
  em.non-terminal { }
  em.non-termina-def { }
  code.literal { font-style: normal; font-weight: bold; color: green }
  code.literal:before { content: "“"; color: black }
  code.literal:after { content: "”"; color: black }
</style>
  </head><body>

<div class="title">
<H1>Title</H1>
XML reader syntax
</div>

<H1>Author</H1>
<p>Per Bothner <code><a href="mailto:per@bothner.com">&lt;per@bothner.com&gt;</a></code></p>

<h1 id="status">Status</h1>
<p>
This SRFI is currently in ``draft'' status.  To see an explanation of
each status that a SRFI can hold, see <a
href="http://srfi.schemers.org/srfi-process.html">here</a>.

To provide input on this SRFI, please
<a href="mailto:srfi minus 107 at srfi dot schemers dot org">mail to
<code>&lt;srfi minus 107 at srfi dot schemers dot org&gt;</code></a>.  See
<a href="../../srfi-list-subscribe.html">instructions here</a> to
subscribe to the list.  You can access previous messages via
<a href="mail-archive/maillist.html">the archive of the mailing list</a>.
</p>

<ul>
      <li>Received: <a href="http://srfi.schemers.org/srfi-107/srfi-107-1.1.html">2012/11/03</a></li>

      <li>Draft: 2012/11/10-2013/01/10</li>
      <li>Revision: <a href="http://srfi.schemers.org/srfi-107/srfi-107-1.2.html">2013/02/04</a></li>
</ul>

<p>
The <a href="http://www.gnu.org/software/kawa/index.html">Kawa Scheme</a>
implementation has <a href="http://www.gnu.org/software/kawa/XML-literals.html">working support</a> for this reader extension.
(Some details are still in flux, depending on how this specification ends up.)
</p>

<h1>Abstract</h1>
<p>
We specify a reader extension that reads data in a superset of
XML/HTML format, and produces conventional S-expressions.
We also suggest a possible semantics interpretation of how these forms
may be evaluated to produce XML-node values, but this is non-normative (???).

</p><h1>Rationale</h1>
<p>
While XML may be a poor re-invention of S-expressions,
many people are familiar with it.  Furthermore, when
working with XML or HTML data, using XML syntax may be preferable
to S-expressions.  This specification defines a Scheme
reader extension matching XML syntax with expression escapes (unquote),
a translation into standard S-expressions, and a semantics for the latter.
</p><p>
Some other programming languages also define a syntax
for XML literals.  Examples include
<a href="http://www.ecma-international.org/publications/standards/Ecma-357.htm">EcmaScript for XML (E4X)</a>,
<a href="http://msdn.microsoft.com/en-us/library/bb384629.aspx">Visual Basic</a>, and <a href="http://www.w3.org/TR/2010/REC-xquery-20101214/#id-element-constructor">XQuery.</a>
</p><p>
Here is a simple example:
</p><pre>#&lt;p&gt;The result is &lt;b&gt;final&lt;/b&gt;!&lt;/p&gt;
</pre>
Actually, these are really <q>quasi-literals</q>
since they can contain enclosed expressions, which are <q>unquoted</q>:
<pre>#&lt;em&gt;The result is &amp;[result].&lt;/em&gt;
</pre>
<p>The value of <var>result</var> is substituted into the output,
in a similar way to quasi-quotation.
Notice the use of <q><code>&amp;</code></q>, which is used in XML
for character and entity references, but we use it as a multi-purpose prefix
character to avoid adding extra special characters that
might need escaping.
</p><p>
The specification does not define a Scheme API for working with XML data.
It assumes there is some data type which we here call an <dfn>XML-node</dfn>.
This specification does not require the XML-node type to be distinct from
other types.  Many Scheme XML libraries just use lists to encode XML-nodes.
However, newer Schemes that have an extensible type system
are encouraged to make XML-node a distinct type.
This follows the <a href="http://www.w3.org/TR/DOM-Level-3-Core/">W3C Document Object Model (DOM)</a>.
</p><p>
The XML data model distinguishes between a document node
and a document element.
A document element is just an XML element
node that is the top-level element in a document.
A document node is a special kind of node whose primary child
is the document element, but may have other children (comments and
process-instructions).
This specification provides a syntax for creating XML elements,
but does not have any special provisions for creating document nodes.
</p><p>
<b>Discussion:</b> Is has been suggested that this specification is
over-large, and that it should focus on just the reader syntax and
on how it is mapped to S-expressions, leaving the <q>semantics</q>
for other specification(s).
Alternatively, re-organization is suggested. (See Cowan 2012-11-18.)
</p><p><b>Discussion:</b> <i>(Not necessarily part of this specification,
but perhaps a future specification.)</i>
It seems useful to specify a syntax for
document nodes.  One solution is to use a SRFI-108 named literal,
whose body is the XML text (with optional enclosed expressions).
For example:
</p><pre>#xml{&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;body&gt;Hello &amp;[name]!&lt;/&gt;
&lt;/html&gt;}
</pre>
<p>One could also support more structured prefix arguments:
</p><pre>#&amp;xml[version: 1.1 encoding: "UTF-8" standalone: #t
  doctype: "HTML"
  public: "-//W3C//DTD HTML 4.01 Transitional//EN"]
{<!--comment-->
&lt;html&gt;...&lt;/&gt;
}
</pre>

<h1>Specification</h1>
<p>An <var class="replaceable"><code>xml-literal</code></var> is usually an element constructor.
We'll cover later the less common processing-instruction,
comment, and CDATA-section forms.
</p>
<pre><var class="non-terminal-def">xml-literal</var> ::= <code class="literal">#</code><var class="non-terminal">xml-constructor</var>
</pre>
<pre><var class="non-terminal-def"><code>xml-constructor</code></var> ::= <var class="non-terminal">xml-element-constructor</var>
  | <var class="non-terminal">xml-PI-constructor</var>
  | <var class="non-terminal">xml-comment-constructor</var>
  | <var class="non-terminal">xml-CDATA-constructor</var>
</pre>

<h3 class="title">Qualified names</h3>
<p>The names of elements and attributes are <var class="firstterm">qualified names</var>
(QNames).
The lexical syntax for a QName is either a simple identifier,
or a (prefix,local-name) pair:
</p>
<pre><var class="non-terminal-def">QName</var> ::= <var class="non-terminal">xml-local-part</var>
   | <var class="non-terminal">xml-prefix</var><code class="literal">:</code><var class="non-terminal">xml-local-part</var>
<var class="non-terminal-def">xml-local-part</var> ::= <var class="non-terminal">identifier</var>
<var class="non-terminal-def">xml-prefix</var> ::= <var class="non-terminal">identifier</var>
</pre>
<p>
Sometimes one needs to calculate the QName at runtime,
evaluating an expression instead of using a literal QName:
</p><pre><var class="non-terminal-def">xml-name-form</var> ::= <var class="non-terminal">QName</var>
  | <var class="non-terminal">xml-enclosed-expression</var>
<var class="non-terminal-def">xml-enclosed-expression</var> ::=
    <code class="literal">[</code><var class="non-terminal">expression</var><code class="literal">]</code>
  | <code class="literal">(</code><var class="non-terminal">expression</var>...<code class="literal">)</code>
</pre>
<p>
The first variant is the general case; the second variant <code class="literal">(</code><var class="non-terminal">expression</var>...<code class="literal">)</code> is just syntactic sugar for:
<code class="literal">[(</code><var class="non-terminal">expression</var>...<code class="literal">)]</code>.  For example the following equivalent forms:
</p><pre>#&lt;[(if be-bold 'strong 'em)]&gt;important&lt;/&gt;
#&lt;(if be-bold 'strong 'em)&gt;important&lt;/&gt;
</pre>
<p>
When evaluating the <var class="non-terminal">expression</var> (in the first variant), the result is a <q>QName value</q>.  While this specification does
not define an API or representation for QName values, it is an object
with three string components: The <dfn>local name</dfn> part,
the <dfn>prefix</dfn> part,
and the <dfn>namespace URI</dfn> part.
The local name and the prefix parts match the parts in a literal QName,
while the namespace URI part is an arbitrary globally unique string.
Two QNames are considered equivalent if they have the same
local name part and namespace URI part, even if the prefix parts are
different.  The prefix is used for input and output;
it can be considered a local nickname for a namespace URI.
The binding from a prefix to a namespace URI can be defined
using <var class="non-terminal">namespace-declaration-attribute</var>.
An implementation may also define such bindings using Scheme code; for example
Kawa has a <code>define-namespace</code> form. 
</p><p>
This specification specifies that a symbol is considered
equivalent to a QName whose local name part is the string name of the
symbol, and whose prefix and namespace URI are both empty,
as long as the name of the symbol matches the syntax of
<var class="non-terminal">identifier</var>, and does not contain a colon.
The result is implementation-defined if a symbol's name contains a colon.

</p><h3 class="title">Element constructors</h3>
<pre><var class="non-terminal-def">xml-element-constructor</var> ::=
    <code class="literal">&lt;</code><var class="non-terminal">QName</var> <var class="non-terminal">xml-attribute</var>...<code class="literal">&gt;</code><var class="non-terminal">xml-element-datum</var>...<code class="literal"><span class="bold"><strong>&lt;/</strong></span></code><var class="non-terminal"><code>QName</code></var> <code class="literal">&gt;</code>
  | <code class="literal"><span class="bold"><strong>&lt;</strong></span></code><var class="non-terminal">xml-name-form</var> <var class="non-terminal">xml-attribute</var>...<code class="literal"><span class="bold"><strong>&gt;</strong></span></code><var class="non-terminal">xml-element-datum</var>...<code class="literal"><span class="bold"><strong>&lt;/&gt;</strong></span></code>
  | <code class="literal">&lt;</code><var class="non-terminal"><code>xml-name-form</code></var> <var class="non-terminal">xml-attribute</var>...<code class="literal">/&gt;</code>
</pre>

<p>The first <var class="replaceable"><code>xml-element-constructor</code></var> variant uses a literal <var class="replaceable"><code>QName</code></var>,
and looks like standard non-empty XML element, where the starting <var class="replaceable"><code>QName</code></var>
and the ending <var class="replaceable"><code>QName</code></var> must match exactly:
</p>
<pre class="screen">#&lt;a href="next.html"&gt;Next&lt;/a&gt;
</pre>
<p>As a convenience, you can leave out the ending tag(s):
</p>
<pre class="screen">&lt;para&gt;This is a paragraph in &lt;emphasis&gt;DocBook&lt;/&gt; syntax.&lt;/&gt;
</pre>

<p>You can use an expression to compute the element tag at runtime -
in that case you <em>must</em> leave out the ending tag:
</p>
<pre class="screen">#&lt;p&gt;This is &lt;[(if be-bold 'strong 'em)]&gt;important&lt;/&gt;!&lt;/p&gt;
</pre>
<p>The third <var class="replaceable"><code>xml-element-constructor</code></var> variant above is an XML
“empty element”; it is equivalent to the second variant
when there are no <var class="replaceable"><code>xml-element-datum</code></var> items.
</p>
<p>(Note that every well-formed XML element, as defined in the XML specifications,
is a valid <var class="replaceable"><code>xml-element-constructor</code></var>, but not vice versa.)
</p>

<h3 class="title">Element contents (children)</h3>
<p>The “contents” (children) of an element
are a sequence of character (text) data,
nested nodes, and enclosed (unquoted) expressions.
The latter are discussed later.
The characters <code class="literal">&amp;</code>, <code class="literal">&lt;</code>, and <code class="literal">&gt;</code> are special,
and need to be escaped.
</p>
<pre><var class="non-terminal-def">xml-element-datum</var> ::=
    any character except <code class="literal">&amp;</code>, or <code class="literal">&lt;</code>.
  | <var class="non-terminal">xml-constructor</var>
  | <var class="non-terminal">xml-escaped</var>
</pre>
<p>
A nested <var class="non-terminal">xml-constructor</var>
is equivalent to an <var class="non-terminal">xml-literal</var>
(i.e. the <var class="non-terminal">xml-constructor</var> prefixed
by a <code class="literal">#</code>) inside an enclosed expression.
For example:
</p><pre>#&lt;p&gt;This is &lt;em&gt;important&lt;/em&gt;!&lt;/p&gt;
</pre>
is equivalent to:
<pre>#&lt;p&gt;This is &amp;{#&lt;em&gt;important&lt;/em&gt;}!&lt;/p&gt;
</pre>
<pre><var class="non-terminal-def">xml-escaped</var> ::=
    <code class="literal">&amp;</code><var class="non-terminal">xml-enclosed-expression</var>
  | <code class="literal">&amp;</code><var class="non-terminal">xml-entity-name</var><code class="literal">;</code>
  | <var class="non-termal">xml-character-reference</var>
<var class="non-terminal-def">xml-character-reference</var> ::=
    <code class="literal">&amp;#</code> <var class="non-terminal">digit</var> <var class="non-terminal">digit</var>... <code class="literal"><span class="bold"><strong>;</strong></span></code>
  | <code class="literal">&amp;#x</code> <var class="replaceable">hex-digit</var> <var class="non-terinal">hex-digit</var>... <code class="literal">;</code>
</pre>
<p>Here is an example with both hex and decimal character references:
</p>
<pre class="screen">#&lt;p&gt;A&amp;#66;C&amp;#x44;E&lt;/p&gt;  ⟹  &lt;p&gt;ABCDE&lt;/p&gt;
</pre>
<pre><var class="non-terminal-def">xml-entity-name</var> ::= <var class="non-terminal">identifier</var>
</pre>
<p>Currently, the only supported values for <var class="replaceable"><code>xml-entity-name</code></var>
are the builtin XML names <code class="literal">lt</code>, <code class="literal">gt</code>, <code class="literal">amp</code>,
<code class="literal">quot</code>, and <code class="literal">apos</code>, which stand for the characters
<code class="literal">&lt;</code>, <code class="literal">&gt;</code>, <code class="literal">&amp;</code>, <code class="literal">"</code>, and <code class="literal">'</code>, respectively.
The following two expressions are equivalent:
</p>
<pre class="screen">#&lt;p&gt;&amp;lt; &amp;gt; &amp;amp; &amp;quot; &amp;apos;&lt;/p&gt;
#&lt;p&gt;&amp;{"&lt; &gt; &amp; \" '"}&lt;/p&gt;
</pre>

<h3>Attributes</h3>
<p>
An attribute associates an attribute name with an attribute value.
This is done using a <var class="non-terminal">xml-true-attribute</var> form,
which is an <var class="non-terminal">xml-attribute</var>
that does <em>not</em> have the form of
<var class="non-terminal">xml-namespace-declaration-attribute</var>.
I.e. in a <var class="non-terminal">xml-true-attribute</var> the
attribute name may not be the special reserved name
<code class="literal">xmlns</code>, nor may it be a QName whose
prefix is the special reserved name <code class="literal">xmlns</code>.
</p><pre><var class="non-terminal-def">xml-attribute</var> ::=
    <var class="non-terminal">xml-true-attribute</var>
  | <var class="non-terminal">xml-namespace-declaration-attribute</var>
</pre>
<p>A true attribute has the form <code><var>name</var>=<var>value</var></code>.
It can also be an enclosed expression that evaluates to an attribute node value.
</p><pre><var class="non-terminal-def">xml-true-attribute</var> ::=
    <var class="non-terminal">xml-name-form</var><code class="literal">=</code><var class="non-terminal">xml-attribute-value</var>
  | <var class="non-terminal">xml-enclosed-expression</var>
<var class="non-terminal-def">xml-attribute-value</var> ::=
    <code class="literal">"</code> <var class="non-terminal">quot-attribute-datum</var><sup>*</sup> <code class="literal">"</code>
  | <code class="literal">'</code> <var class="non-terminal">apos-attribute-datum</var><sup>*</sup> <code class="literal">'</code>
</pre>
<pre><var class="non-terminal-def">quot-attribute-datum</var> ::=
    any character except <code class="literal">"</code>, <code class="literal">&amp;</code>, or <code class="literal">&lt;</code>.
  | <var class="non-terminal">xml-escaped</var>
<var class="non-terminal-def">apos-attribute-datum</var> ::=
    any character except <code class="literal">'</code>, <code class="literal">&amp;</code>, or <code class="literal">&lt;</code>.
  | <var class="non-terminal">xml-escaped</var>
</pre>
<p></p>
<p><b>Discussion:</b> When an attribute-value is specified by an expression,
having to writes an <var class="non-terminal">xml-escaped</var> inside
string quotes seems clumsy.  We codul allow the much simpler:
</p><pre><var class="non-terminal-def">xml-attribute-value</var> ::= ...
  | <code class="literal">[</code> <var class="non-terminal">expression</var> <code class="literal">]</code>
</pre>

<h3 class="title" id="enclosed-expression-handling">Handling of enclosed expressions</h3>
<p>
Both element content and attribute values may contain
<var class="non-terminal">xml-enclosed-expression</var>s.
These are expressions evaluated at runtime, where the
evaluated result becomes part of the element content or the attribute value.
</p><p>
If the expression evaluates to an element, comment, or
processing node, and the context is element content,
then the node is added as a child of the element.
It is unspecified if the node is copied or shared.
It is also unspecified if the expression result is some
other kind of XML-node, or the context is an attribute value.
</p><p>
If the expression evaluates to a string, the result is pasted
as a text (child) content of an element or a substring of an
attribute value, respectively.
</p><p>
If the expression evaluates to a CDATA segement, the result
is equivalent to the string value of the segment.
</p><p>
If the expression evaluates to some other scalar value
(including numbers, booleans, and characters) the value
is converted to a string according to implementation-specified
rules.  An implementation MAY convert a value as if
using <code>display</code>.  Alternatively, an implementation MAY convert
a value to yield a canonical representation according to the XML
Schema specification.  (In the latter case, Booleans <code>#f</code>
and <code>#t</code> should yield <code>false</code> and <code>true</code>,
respectively.)
</p><p>
If the expression evaluates to a list or vector, then each element
is inserted into the element or attribute content.  Spaces are inserted
between two elements if neither element is an XML-node.
</p><p>
Note that some XML specifications (include XML Schema and the
<a href="http://www.w3.org/TR/xpath-datamodel/">XQuery and XPath data model</a>)
have the concept of <dfn>typed value</dfn> of a node.
The typed value may be a number, a string, or another
atomic type.  The typed value may also be a sequence of strings,
numbers, or other atomic values.  Some implementations
may optionally store the typed value instead of or in addition
to the text value.  For example:
</p><pre>#&lt;prices&gt;&amp;(vector 230 599 98 763)&lt;/prices&gt;
</pre>
<p>
It is undefined if in the XML-node the contents is stored as a
sequence of 4 integers, or as the string <code>"230 599 98 763"</code>,
as long as the result prints the same way.

</p><h3 class="title">Namespace declarations</h3>

<p>An <var class="replaceable"><code>xml-prefix</code></var> is an alias for a namespace-uri,
and the mapping between them is defined by a <var class="firstterm">namespace declaration attribute</var>,
which has the form of an <var class="non-terminal">xml-attribute</var>
where either the QName or the prefix is the special identifier
<code class="literal">xmlns</code>:
</p>
<pre><var class="non-terminal-def">xml-namespace-declaration-attribute</var> ::=
    <code class="literal">xmlns:</code><var class="non-terminal">xml-prefix</var><code class="literal">=</code><var class="non-terminal">xml-attribute-value</var>
  | <code class="literal">xmlns=</code><var class="non-terminal">xml-attribute-value</var>
</pre>
<p>The former declares <var class="replaceable"><code>xml-prefix</code></var> as a namespace alias for
the namespace-uri specified by <var class="replaceable"><code>xml-attribute-value</code></var>
(which must be a compile-time constant).
The second declares that <var class="replaceable"><code>xml-attribute-value</code></var> is the default
namespace for simple (unprefixed) element tags.
(A default namespace declaration is ignored for attribute names.)
</p>

<h3 class="title">Processing instructions</h3>
<p>An <var class="replaceable"><code>xml-PI-constructor</code></var> can be used to create an XML
<var class="firstterm">processing instruction</var>, which can be used to pass
instructions or annotations to an XML processor or tool.</p>
<pre><var class="non-terminal-def">xml-PI-constructor</var> ::= <code class="literal">&lt;?</code><var class="non-terminal">xml-PI-target</var> <var class="non-terminal">xml-PI-content</var><code class="literal">?&gt;</code>
<var class="non-terminal-def">xml-PI-target</var> ::= <var class="nn-terminal">NCname</var> (i.e. a simple (non-compound) identifier)
<var class="non-terminal=def">xml-PI-content</var> ::= any characters, not containing <code class="literal">?&gt;</code>.
</pre>
<p>For example, the DocBook XSLT stylesheets can use the <code class="literal">dbhtml</code>
instructions to specify that a specific chapter should be
written to a named HTML file:
</p>
<pre class="screen">#&lt;chapter&gt;&lt;?dbhtml filename="intro.html" ?&gt;
&lt;title&gt;Introduction&lt;/title&gt;
...
&lt;/chapter&gt;
</pre>


<h3 class="title">XML comments</h3>
<p>You can cause XML comments to be emitted in the XML output document.
Such comments can be useful for humans reading the XML document,
but are usually ignored by programs.
</p>
<pre><var class="non-terminal-def">xml-comment-constructor</var> ::= <code class="literal">&lt;!--</code><var class="don-terminal">xml-comment-content</var><code class="literal">--&gt;</code>
<var class="dnon-terminal-def">xml-comment-content</var> ::= any characters, not containing <code class="literal">--</code>.
</pre>

<h3 class="title">CDATA sections</h3>
<p>A <code>CDATA</code> section can be used to avoid excessive
quoting in element content.
</p>
<pre><var class="non-terminal-def">xml-CDATA-constructor</var> ::= <code class="literal">&lt;![CDATA[</code><var class="non-terminal">xml-CDATA-content</var><code class="literal">]]&gt;</code>
<var class="non-terminal-def">xml-CDATA-content</var> ::= any characters, not containing <code class="literal">]]&gt;</code>.
</pre>
<p>
A CDATA section is semantically equivalent to text
consitsing of the <var class="non-terminal">xml-CDATA-content</var>,
though some XML-node representations may
record that the text came from a CDATA so it can be written out the same way.
(Kawa does this.)
</p><p>The following are equivalent:
</p>
<pre class="screen">#&lt;p&gt;Special characters &lt;![CDATA[&lt; &gt; &amp; ' "]]&gt; here.&lt;/p&gt;
#&lt;p&gt;Special characters &amp;lt; &amp;gt; &amp;amp; &amp;quot; &amp;apos; here.&lt;/p&gt;
</pre>

<h3>Output of XML nodes</h3>

<p>
If XML-node is a separate data-type, implementations
are encouraged to use this XML-literal format when writing to an output port,
since this provides input-output round-tripping.
Specifically, calling <code>write</code> on an XML-node SHOULD write
an <var class="non-terminal">xml-literal</var> (with an initial
<code class="literal">#</code>).
The <var class="non-terminal">xml-constructor</var> SHOULD be in standard XML
syntax without using any of extensions in this specification, such
as an unnamed end tag.
Calling <code>display</code> on an XML-node SHOULD write
an <var class="non-terminal">xml-constructor</var> (without an initial
<code class="literal">#</code>).  Alternatively, if the output port
is an extended port that can handle <q>rich text</q> then an
implementation MAY instead display a styled representation.
For example if the XML-node is compatible with HTML, and the
output port is inserting text into a browser, then the implementation
may copy the DOM into the browser, perhaps resulting in styled text.

</p><h3>Translation</h3>
<p>
The following specifies how the reader syntax is translated by the reader into
standard S-expressions. These basically create macro invocations; the
implementation is responsible for implementing those macros as
described in the <a href="#translated-forms">Translated forms</a> section.  As an example:
</p><pre>#&lt;a class="title"&gt;Result: &amp;{sum}.&lt;/a&gt;
</pre>
is read as if it were:
<pre>($xml-element$ () ($resolve-qname$ a)
  ($xml-attribute$ 'class "title")
  "Result: " sum ".")
</pre>
<p>
The <code>()</code> in the result is the translation
of any namespace declaration attributes - in this case none.
</p><p>
The translation is defined in terms of a recursive read-time
<q>translation function</q> <b>Tr</b> which maps
an <var class="non-terminal">xml-constructor</var> to an S-expression.
</p><p>
<strong>Note:</strong>  This translation is preliminary.
It may need to be tweaked (and debugged) a bit.
</p><p>
</p><pre><b>Tr[</b><code class="literal">&lt;</code><var class="non-terminal">QName</var> <var class="non-terminal">xml-attribute</var>...<code class="literal">&gt;</code><var class="non-terminal">xml-element-datum</var>...&lt;/<var class="non-terminal">QName</var>&gt;<b>]</b>
  ⟾ <b>Tr[</b><code class="literal">&lt;</code><var class="non-terminal">QName</var> <var class="non-terminal">xml-attribute</var>...&gt;<var class="non-terminal">xml-element-datum</var>...&lt;/&gt;<b>]</b>
<b>Tr[</b><code class="literal">&lt;</code><var class="non-terminal">xml-name-form</var> <var class="non-terminal">xml-attribute</var>...&gt;<var class="non-terminal">xml-element-datum</var>...&lt;/<var class="non-terminal">QName</var>&gt;<b>]</b>
  ⟾ <code class="literal">&lt;($xml-element$ (</code><b>TrNamespaceDecl[</b><var class="non-terminal">xml-attribute</var><b>]...</b><code class="literal">)</code> <b>TrElementName[</b><var class="non-terminal">xml-name-form</var><b>]</b> <b>TrAttr[</b><var class="non-terminal">xml-attribute</var><b>]</b>... <b>TrContent[</b><var class="non-terminal">xml-element-datum</var><b>]</b>...<code class="literal">)</code>
<b>TrAttr[</b><var class="non-terminal">xml-namespace-declaration-attribute</var><b>]</b>
  ⟾ <code class="literal">#|nothing|#</code>
<b>TrAttr[</b><var class="non-terminal">xml-name-form</var><code class="literal">=</code><var class="non-terminal">xml-attribute-value</var><b>]</b>
  ⟾ <code class="literal">($xml-attribute</code> <b>TrAttrName[</b><var class="non-terminal">xml-name-form</var><b>]</b> <b>TrContent[</b><var class="non-terminal">xml-attribute-value</var><b>]</b><code class="literal">)</code>
</pre>

<pre><b>TrChar[</b>any character except &amp;, or &lt;<b>]</b>
  ⟾ any character except &amp;, or &lt;
<b>TrChar[</b><code class="literal">&amp;#x</code> <var class="replaceable">hex-digit</var> <var class="non-terminal">hex-digit</var>... <code class="literal">;</code><b>]</b>
  ⟾ <code class="literal">\x</code><var class="replaceable">hex-digit</var> <var class="non-terminal">hex-digit</var>... <code class="literal">;</code>
<b>TrChar[</b><code class="literal">&amp;#x</code> <var class="replaceable">digit</var> <var class="non-terminal">digit</var>... <code class="literal">;</code><b>]</b>
  ⟾ <code class="literal">\x</code><i>corresponding hex-digits</i><code class="literal">;</code>
<b>TrContent[</b>simple-char...<b>]</b>
  ⟾ <code class="literal">"</code><b>TrChar[</b>simple-char<b>]</b>...<code class="literal">"</code>
<b>TrContent[</b><code class="literal">&amp;</code><var class="non-terminal">xml-entity-name</var><code class="literal">;</code><b>]</b>
  ⟾ <code class="literal">($entity-reference$</code> <var class="non-terminal">xml-entity-name</var><code class="literal">)</code>
<b>TrContent[</b><code class="literal">{</code><var class="non-terminal">expression</var><code class="literal">}</code><b>]</b>
  ⟾ <var class="non-terminal">expression</var>
<b>TrContent[</b><code class="literal">{</code><var class="non-terminal">string-literal</var><code class="literal">}</code><b>]</b>
  ⟾ <code class="literal">(quote</code> <var class="non-terminal">string-literal</var><code class="literal">)</code>
<b>TrContent[</b><code class="literal">&amp;{</code><var class="non-terminal">expression</var>...<code class="literal">}</code><b>]</b>
  ⟾ <var class="non-terminal">expression</var>...
<b>TrContent[</b><code class="literal">(</code><var class="non-terminal">expression</var>...<code class="literal">)</code><b>]</b>
  ⟾ <code class="literal">(</code><var class="non-terminal">expression</var>...<code class="literal">)</code>
</pre>
<p>
Note that a string literal in an enclosed expression is handled specially
by enclosing it a <code>quote</code> form.  This is allows a macro to
distinguish an enclosed expression from literal content; that may sometimes
be useful.
<!--<p>
<strong>Note:</strong> Some XML processor distinguish XML text nodes
from atomic string values in various ways.  The critical issue for us here
is this:  If you have a sequence of atomic string values and you insert
them as element content, you separate each with a single space.
If you have a sequence of text nodes and you insert
them (copy them) as element content, don't don't separate them with spaces.-->

</p><pre><b>TrNamespaceDecl[</b><var class="non-terminal">xml-true-attribute</var><b>]</b>
  ⟾ <code class="literal">#|nothing|#</code>
<b>TrNamespaceDecl[</b><code class="literal">xmlns:</code><var class="non-terminal">xml-prefix</var><code class="literal">=</code><var class="non-terminal">xml-attribute-value</var><b>]</b>
  ⟾ <code class="literal">(</code><b>TrContent[</b><var class="non-terminal">xml-attribute-value</var><b>]</b> <var class="non-terminal">xml-prefix</var><code class="literal">)</code>
<b>TrNamespaceDecl[</b><code class="literal">xmlns=</code><var class="non-terminal">xml-attribute-value</var><b>]</b>
  ⟾ <code class="literal">(</code><b>TrContent[</b><var class="non-terminal">xml-attribute-value</var><b>]</b><code class="literal">)</code>
</pre>
<p>
Element (tag) names are translated by <code><b>TrElementName</b></code>,
while attribute names are translated by <code><b>TrAttrName</b></code>.
These are both handled by <code><b>TrElementOrAttrName</b></code> in both cases.
However, if there is no namespace-prefix, then attribute names default
to the empty namespace, but element names default to the current
default element namespace prefix (indicated by <code>$default-element-namespace$</code>).
</p><pre><b>TrElementName[</b><var class="non-terminal">identifier</var><b>]</b>
  ⟾ <code class="literal">($resolve-qname$</code> <var class="non-terminal">identifier</var> <code class="literal">)</code>
<b>TrAttrName[</b><var class="non-terminal">identifier</var><b>]</b>
  ⟾ <code class="literal">(quote</code> <var class="non-terminal">identifier</var><code class="literal">)</code>
<b>TrAttrName[</b><var class="non-terminal">other-form</var><b>]</b>
  ⟾ <b>TrElementOrAttrName[</b><var class="non-terminal">other-form</var><b>]</b>
<b>TrElementName[</b><var class="non-terminal">other-form</var><b>]</b>
  ⟾ <b>TrElementOrAttrName[</b><var class="non-terminal">other-form</var><b>]</b>
<b>TrElementOrAttrName[</b><var class="non-terminal">prefix</var><code class="literal">:</code><var class="non-terminal">local-name</var><b>]</b>
  ⟾ <code class="literal">($resolve-qname$</code> <var class="non-terminal">local-name</var> <var class="non-terminal">prefix</var> <code class="literal">)</code>
<b>TrElementOrAttrName[</b><code class="literal">(</code><var class="non-terminal">expression</var><code class="literal">)</code><b>]</b>
  ⟾ <code class="literal">(</code><var class="non-terminal">expression</var><code class="literal">)</code>
<b>TrElementOrAttrName[</b><code class="literal">{</code><var class="non-terminal">expression</var><code class="literal">}</code><b>]</b>
  ⟾ <var class="non-terminal">expression</var>
</pre>
<p>The special node constructors are translated similarly:
(<b>Note</b> This is not quite right, since these forms should not handle
escape characters the way element and attribute content does.)
</p><pre><b>Tr[</b><code class="literal">&lt;![CDATA[</code><var class="non-terminal">xml-CDATA-content</var><code class="literal">]]&gt;</code><b>]</b>
  ⟾ <code class="literal">($xml-CDATA$</code> <code class="literal">"</code><var class="non-terminal">xml-CDATA-content</var><code class="literal">")</code>
<b>Tr[</b><code class="literal">&lt;--</code><var class="non-terminal">xml-comment-content</var><code class="literal">--&gt;</code><b>]</b>
  ⟾ <code class="literal">($xml-comment$</code> <code class="literal">"</code><var class="non-terminal">xml-comment-content</var><code class="literal">")</code>
<b>Tr[</b><code class="literal">&lt;?</code><var class="non-terminal">xml-PI-target</var> <var class="non-terminal">xml-PI-content</var><code class="literal">?&gt;</code><b>]</b>
  ⟾ <code class="literal">($xml-processing-instruction</code> <var class="non-terminal">xml-PI-target</var> <b>TrContent[</b><var class="non-terminal">xml-PI-content</var><b>]</b><code clas="literal">)</code>
</pre>

<h3 id="translated-forms">Translated forms</h3>
<p>
The above translation maps the new reader syntax to 
S-expressions using macros specified in this section.
Of course it is possible to write these macro forms directly,
though they are less human-readable.  However, code generators
and macros may target these macros.  This format can also
be used as an interchange format.
</p><pre><code class="literal">($xml-element$</code> <code class="literal">(</code> (<var class="non-terminal">namespace-binding</var>...) <code class="literal">)</code> <var class="non-terminal">name</var> <var class="non-terminal">attribute</var>... <var class="non-terminal">content</var>... <code class="literal">)</code> 
</pre>
<p>
Creates an element node.
</p><p>
Each <var class="non-terminal">namespace-binding</var>
is a one- or two-element list <code>(<var class="non-terminal">namespace-uri</var> [<var class="non-terminal">prefix</var>])</code>.
The <var class="non-terminal">prefix</var> is a literal symbol
that represents a namespace prefix; if missing it defaults to the
symbols <code>$default-element-namespace$</code>.
The <var class="non-terminal">namespace-uri</var>
is a literal string.  (An possible extension is to allow an
expression that evaluates to a string.)
</p><p>
The <var class="non-terminal">name</var> is an expression that
evaluates to a symbol or a QName, most commonly a quoted symbol
or a <code>$resolve-qname$</code> form.
</p><p>
The binding for <code>$xml-element$</code> must be a macro, not a function,
because each <var class="non-terminal">namespace-binding</var>
adds a (prefix,URI)-binding in the lexical context.  That binding is 
used to evaluate QNames in the remaining parameters, which are all 
expressions.
</p><p>
Each <var class="non-terminal">attribute</var> is usually
an <code>$xml-attribute$</code> form, but an implementation may support
oter expressions that evaluate to <q>attribute nodes</q>.
Each <var class="non-terminal">content</var> is an expression
that evaluates to to element content, handled as described in the
<a href="#enclosed-expression-handling">Handling of enclosed expressions</a> section.
</p><pre><code class="literal">($xml-attribute$</code> <var class="non-terminal">name</var> <var class="non-terminal">content</var>... <code class="literal">)</code> 
</pre>
<p>
Creates an attribute node from the parameters.
The <var class="replaceable">name</var> is an expression that evaluates to a symbol or QName value.  The <var class="non-terminal">content</var> arguments
are concatenated to produce the attribute value.

</p><pre><code class="literal">($resolve-qname$</code> <var class="non-terminal">local-name</var> [<var class="non-terminal">prefix</var>]<code class="literal">)</code> 
</pre>
<p>
Resolve the gives <var class="non-terminal">prefix</var>/<var class="non-terminal">local-name</var>-pair to a QName value.  Both arguments are literal
unquoted symbols.  If <var class="non-terminal">prefix</var> is
missing it defaults <code class="literal">$default-element-namespace$</code>.
</p><pre><code class="literal">($xml-comment$</code> <var class="non-terminal">content</var>...<code class="literal">)</code> 
</pre>
<pre><code class="literal">($xml-CDATA$</code> <var class="non-terminal">content</var>...<code class="literal">)</code> 
</pre>
<pre><code class="literal">($xml-processing-instruction$</code> <var class="non-terminal">xml-PI-target</var> <var class="non-terminal">content</var>...<code class="literal">)</code> 
</pre>
Creates processing-instruction (PI) node.
The <var class="non-terminal">xml-PI-target</var> should be a symbol
(or a QName in the empty namespace).
The <var class="non-terminal">content</var> arguments should be strings,
which are concatenated.

<pre><code class="literal">($entity-reference$</code> <var class="non-terminal">xml-entity-name</var><code class="literal">)</code>
</pre>
<p>
The argument is an unquoted symbol.
Returns a string value matching the entity name.
For example:
</p><pre>($xml-entityref$ lt) ==&gt; "&lt;"
</pre>
The standard XML entity names (lt, gt, amp, quot, and apos) are
defined at a mininum.  Standard Scheme character names should also be supported.
An implementation may support other names, for example
variables bound in the lexical namespace.

<h1>Implementation</h1>
<p>The implementation is necessarily non-portable, though the
Translation section provides a template for the reader part.
</p><h3>Handling namespaces</h3>
<p>
Implementing of the <a href="#translated-forms">Translated forms</a>
should mostly be obvious: Just call an appropriate function to
create the XML-node.  Handling namespace definitions is non-obvious, however.
The form:
</p><pre>($xml-element$ ((<var class="non-terminal">namespace-uri</var> <var class="non-terminal">prefix</var>)...) <var class="non-terminal">name</var> <var class="non-terminal">attribute</var>... <var class="non-terminal">content</var>...)
</pre>
can be translated into something like:
<pre>(let ()
  (define-namespace <var class="non-terminal">prefix</var> <var class="non-terminal">namespace-uri</var>)
  ...
  (make-element name <var class="non-terminal">attribute</var>... <var class="non-terminal">content</var>... )
</pre>
<p>
The initial environment has pre-defined:
</p><pre>(define-namespace $default-element-namespace$ "")
</pre>
<p>
One way to implement <code>define-namespace</code> is to expand:
</p><pre>(define-namespace <var class="non-terminal">prefix</var> <var class="non-terminal">namespace-uri</var>)
</pre>
to:
<pre>(define $namespace$:<var class="non-terminal">prefix</var> <var class="non-terminal">namespace-uri</var>)
</pre>
<p>
In that case:
</p><pre>($resolve-qname$ <var class="non-terminal">local-name</var> <var class="non-terminal">prefix</var>)
</pre>
<p>
could be implemented as:
</p><pre>(make-qname <var class="non-terminal">local-name</var> <var class="non-terminal">prefix</var> $namespace$:<var class="non-terminal">prefix</var>)
</pre>
<p>
assuming a 3-argument <code>make-qname</code> function that creates a QName
with the given local-name, prefix, and namespace-uri.
Implementations SHOULD provide a custom error message in the case
<code>$namespace$:<var class="non-terminal">prefix</var></code> is
undefined, rather than depend on a generic error message.

</p><h3>Testsuite</h3>
<p>There is a test suite in the
<a href="http://sourceware.org/viewvc/kawa/trunk/testsuite/xml-test.scm?view=co">Kawa source tree</a>.
<!--
There will be testsuite.  This will test at least:
<ul>
<li>Quoted forms allow portable testing of the reader translation.
<li>Format/or write of non-quoted forms allow semi-portable
testing of read-write round-tripping.
<li>Some non-portable tests may be appropriate, for example
using Kawa functionality.
</ul>
-->

</p><h1>Copyright</h1>
<p>
Copyright (C) Per Bothner 2012</p>
<p>
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:</p>
<p>
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.</p>
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<hr>
<address>Author: <a href="mailto:per@bothner.com">Per Bothner</a></address>
<address>Editor: <a href="mailto:srfi-editors%20at%20srfi%20dot%20schemers%20dot%20org">
             Mike Sperber</a></address>


</body></html>